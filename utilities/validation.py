# -*- coding: utf-8 -*-
"""Validation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CukwkxSw-xd3Zw6qJvsepWSNDGRsle3c
"""

import cv2
import os
import sys
import math
import numpy as np
from google.colab.patches import cv2_imshow
import json

from google.colab import drive
drive.mount('/content/drive', force_remount=True)
os.chdir("/content/drive/My Drive/FireDrone.AI/results")

test_path = '/content/drive/My Drive/FireDrone.AI/Data/21'

def create_bitmask(frame):
  image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
  # Condition 1: R > G > B
  cond1a = (image[:, :, 0] > image[:, :, 1])  # r > g
  cond1b = (image[:, :, 1] > image[:, :, 2])  # g > b
  cond1c = (image[:, :, 0] > image[:, :, 2])  # r > b
  cond1t = np.bitwise_and(cond1a, cond1b)
  cond1 = np.bitwise_and(cond1t, cond1c)
  # Condition 2: Y > Cr > Cb
  YCCimg = cv2.cvtColor(image, cv2.COLOR_RGB2YCR_CB)
  cond2a = (YCCimg[:, :, 0] > YCCimg[:, :, 1])  # y > cr
  cond2b = (YCCimg[:, :, 1] > YCCimg[:, :, 2])  # cr > cb
  cond2c = (YCCimg[:, :, 0] > YCCimg[:, :, 2])  # y > cb
  cond2t = np.bitwise_and(cond2a, cond2b)
  cond2 = np.bitwise_and(cond2t, cond2c)
  # Condition 3: Y > mean(Y) and Cr > mean(Cr) and Cb < mean(Cb)
  meanY = np.average(YCCimg[:, :, 0])
  meanCr = np.average(YCCimg[:, :, 1])
  meanCb = np.average(YCCimg[:, :, 2])
  cond3a = (YCCimg[:, :, 0] > meanY)
  cond3b = (YCCimg[:, :, 1] > meanCr)
  cond3c = (YCCimg[:, :, 2] < meanCb)
  cond3t = np.bitwise_and(cond3a, cond3b)
  cond3 = np.bitwise_and(cond3t, cond3c)
  # Condition 4: Setting min and max thresholds for HSV
  hsv_img = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.uint8)
  lower_1 = np.array([4, 100, 220])
  upper_1 = np.array([25, 260, 260])
  hsv1 = cv2.inRange(hsv_img, lower_1, upper_1)
  lower_2 = np.array([50, 100, 220])
  upper_2 = np.array([70, 260, 260])
  hsv2 = cv2.inRange(hsv_img, lower_2, upper_2)
  hsv_mask = cv2.bitwise_or(hsv1, hsv2)
  # Combining the Conditions
  comb = np.bitwise_and(cond1, cond3)
  image[comb == 0] = [0, 0, 0]
  flame = cv2.bitwise_and(image, image, mask=hsv_mask)
  grey = cv2.cvtColor(flame, cv2.cv2.COLOR_BGR2GRAY)
  BW_flame = cv2.threshold(grey, 10, 1, cv2.THRESH_BINARY)[1]
  return BW_flame


def test_image(self,img):
    img = cv2.imread(os.path.join(test_path,img))
    org = img.copy()
    img = cv2.resize(img, dsize=(self.NEW_DIM, self.NEW_DIM), interpolation=cv2.INTER_AREA)
    img = img.astype("float")/255.0
    img = img_to_array(img)
    img = np.expand_dims(img, axis=0)
    percentage = self.trained_model.predict(img)[0][0] * 100
    label = "Fire Percentage(%): " + str(percentage)
    cv2.putText(org, label, (10,25), cv2.FONT_HERSHEY_SIMPLEX,0.7, (0, 255, 0), 2)
    cv2_imshow(org)


def validate_persistent_mask():
  detected_fire = 'frame210405.png'
  didnt_detect_left = 'frame210305.png'
  cv2_imshow(cv2.imread(os.path.join(test_path,detected_fire)))

  detect_mask = create_bitmask(cv2.imread(os.path.join(test_path,detected_fire)))
  undetect_mask = create_bitmask(cv2.imread(os.path.join(test_path,didnt_detect_left)))

  cv2_imshow(detect_mask)

  cv2_imshow(cv2.imread(os.path.join(test_path,didnt_detect_left)))
  cv2_imshow(undetect_mask)

  detect_mask = np.roll(detect_mask, 100)
  detect_mask[:, 99] = 0
  cv2_imshow(detect_mask)


def validate_scoring(filename):
  with open(filename) as json_file:
    data = json.load(json_file)

  for item in data['Events']:
    if item['EventType'] == 9:
      #s = item['EventDetails'].replace("255", "1")
      s = item['EventDetails']
      arr = list(s)
      arr = [int(i) for i in arr]
      arr = [255*i for i in arr]
      img = np.asarray(arr).astype("float")
      img = np.reshape(img, (-1, 500))
      cv2_imshow(img)


def main():
  validate_scoring('25.json')

if __name__ == "__main__":
    main()